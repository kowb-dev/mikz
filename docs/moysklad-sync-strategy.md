Эффективная синхронизация остатков между МойСклад и WooCommerce
Введение
Синхронизация остатков товаров между системой учёта МойСклад и магазином на WooCommerce – важная задача для актуальности данных. Приблизительно 2000 товаров требуют обновления информации о наличии каждые 10 минут. Однако частое обновление может перегрузить слабый (шаред) хостинг. В этом отчёте рассмотрены современные, эффективные методы синхронизации остатков с минимальной нагрузкой на сервер. Особый акцент сделан на инкрементальном обновлении (только изменившиеся остатки вместо полной выгрузки) и технических решениях: JSON API МоегоСклада, WP-Cron/cron, REST API WooCommerce или обновление метаданных напрямую.
Полная vs. инкрементальная синхронизация остатков
Полная синхронизация означает, что при каждом запуске обмена выгружается весь каталог (например, все 2000 товаров с остатками) и обновляется на сайте. Такой подход прост, но крайне неэффективен: приходится каждый раз пересылать и обрабатывать данные по всем товарам, даже если у большинства из них остаток не менялся. Это создает избыточную нагрузку на API и базу данных сайта. Например, разработчики отметили, что выгрузка ~3600 товаров по двум складам «выполняется очень долго и создаёт ненужную нагрузку», в то время как фактически за интервал меняются остатки лишь у нескольких позиций
ru.stackoverflow.com
. Нет смысла каждый раз сравнивать остатки тысяч товаров, если изменились только 2–3 из них. Инкрементальная (дельта) синхронизация нацелена на обновление только тех товаров, у которых изменился остаток с момента последнего обмена. Этот подход значительно снижает объем данных и операций: если за 10 минут изменились остатки у 5 товаров, то обновятся только они, а остальные 1995 товаров не трогаются. Такой выборочный обмен минимизирует нагрузку на сеть и сервер. Главная проблема в реализации дельта-синхронизации – определить, какие товары изменились. К сожалению, опираться на стандартные поля обновления товаров в МойСклад не всегда корректно. У сущности «ассортимент» (которая включает товары и модификации) есть поле updated для фильтрации по дате обновления, но оно отражает изменения в карточке товара (описание, цена и т.д.), а не обновление остатков
ru.stackoverflow.com
. Иными словами, если товар поступил или продан, и остаток в МойСклад изменился, это не обязательно меняет поле updated товара. Таким образом, простой запрос типа «все товары, обновлённые за последние 10 минут» не гарантирует, что мы получим именно изменения по остаткам. В старых интеграциях часто применяли обмен по CommerceML – выгрузку XML-файла со всем каталогом и его импорт на сайт. Это надёжно для первоначальной загрузки данных, но для регулярной синхронизации остатков это слишком тяжеловесно. Как правило, CommerceML-обмен обновляет всю базу товаров, что не подходит для каждых 10 минут. (Например, в документации PHPShop указано: «Для начального наполнения магазина и синхронизации остатков из МойСклад включите обмен по CommerceML»
docs.phpshop.ru
, подчёркивая, что это метод для начальной или полной загрузки.) Вывод: Для частой синхронизации предпочтительно отказаться от полной выгрузки в пользу инкрементальных обновлений. Ниже рассмотрены современные подходы, позволяющие этого достичь.
Современные методы синхронизации остатков (каждые 10 минут без перегрузки)
1. Webhooks МоегоСклада (пуш-обновления)
Самый эффективный способ избежать лишней нагрузки – вообще не опрашивать сервер по расписанию, а получать уведомление от него, когда произошли изменения. МойСклад поддерживает вебхуки – механизм, при котором система сама отправляет HTTP-запрос на ваш сервер при наступлении определенного события (например, изменился остаток товара). В документации прямо рекомендуется использовать вебхуки для обмена данными в реальном времени и избавиться от периодического опроса изменений
dev.moysklad.ru
dev.moysklad.ru
. Вебхук представляет собой POST-запрос на указанный URL с информацией о событии – тип события и ссылка на объект, который изменился
dev.moysklad.ru
. В случае остатков это может быть событие обновления товара (entityType "product" с action "UPDATE") или специальное событие на изменение остатков. В API версии 1.2 (релиз состоялся после 2019 года) как раз была добавлена возможность отслеживать изменения остатков. На вопрос о дельта-синхронизации остатков разработчики МойСклад ответили: «В ближайшее время будет релиз API 1.2 и в ней будет вебхук на остатки.»
ru.stackoverflow.com
. Это означает, что теперь можно подписаться на события изменения остатков. В сервисе Albato, например, видны конкретные триггеры вебхуков МойСклад: «Обновление остатков после оприходования», «...после отгрузки», «...после приемки», «...после списания», «...после перемещения» и т.д.
albato.ru
albato.ru
 – то есть на каждый тип операции, влияющей на остаток, можно мгновенно отреагировать автоматическим обновлением на сайте. Как это реализовать: Необходимо зарегистрировать вебхук через JSON API МоегоСклада, указав URL вашего сайта и событие. Например, через запрос POST на /entity/webhook с телом, содержащим {"url": "https://example.com/handler", "action": "UPDATE", "entityType": "product"} – это подпишет на события обновления товара
dev.moysklad.ru
. После этого при любом изменении товара (в том числе его остатка) МойСклад отправит на handler уведомление с типом события и ссылкой на объект. Вашему приложению останется обработать этот запрос: по полученной ссылке (например, /entity/product/{id}) сделать GET-запрос к API МоегоСклада, получить актуальный остаток товара и затем обновить его на сайте. Преимущества вебхуков: минимальная задержка (остаток меняется почти мгновенно на сайте) и отсутствие лишних опросов. Нагрузка очень низкая, так как данные передаются только при необходимости. МойСклад официально отмечает, что подписка на вебхуки гарантирует оперативное получение изменений и меньшую нагрузку по сравнению с периодическим опросом
dev.moysklad.ru
. Плагин MSWoo (коммерческая интеграция) поддерживает этот подход: у них прямо указано «плагин умеет работать через вебхуки, что позволяет изменять остатки... моментально»
mswoo.ru
. Возможные сложности: нужно иметь публично доступный URL (SSL) для приёма вебхуков. На шаред-хостинге это обычно не проблема – ваш сайт и так доступен. Внутри WordPress можно создать специальный endpoint (например, WP REST API route или отдельный PHP-файл) для приёма webhook. Вебхуки лишь уведомляют о факте изменения; саму логику обновления надо реализовать (API-запрос к МоемуСкладу и обновление WooCommerce). Также стоит продумать защиту webhook URL (например, секрет в пути или проверка токена), чтобы избежать посторонних вызовов. Если вебхуки доступны – это самый рекомендуемый метод для частой синхронизации, так как он полностью инкрементальный и почти не потребляет ресурсов в холостую.
2. Периодический опрос через JSON API (каждые 10 минут, только изменения)
Если использование вебхуков невозможно (или нежелательно), альтернативой остается периодический опрос (polling). Задача – сделать polling как можно более “умным”, чтобы за один опрос затрагивать только изменившиеся товары. а) Использование отметки времени обновления: Как упоминалось, поле updated товара не гарантирует фиксацию изменения остатков
ru.stackoverflow.com
. Однако стоит проверить актуальную документацию API 1.2+ – возможно, теперь при изменении остатка (например, в результате продажи или прихода) в МойСклад действительно обновляется timestamp товара. Если это так, можно каждые 10 минут выполнять запрос: GET /entity/product?filter=updated>2025-12-05 18:00:00 (подставляя время последней синхронизации). Такой запрос вернул бы список товаров, у которых что-либо обновилось после указанного времени. Нужно убедиться, что смена остатка триггерит обновление объекта товара. Если да – этого достаточно, чтобы получить изменённые товары. Если нет – придется прибегнуть к другим средствам. б) Отчет об остатках с последующей фильтрацией: JSON API МоегоСклада предоставляет специальный отчет: GET /report/stock/bystore – остатки товаров по складам. Он возвращает список товаров с указанием остатков на каждом складе
ru.stackoverflow.com
ru.stackoverflow.com
. Ответ содержит для каждого товара его meta (ссылка/ID) и массив stockByStore – остатки на складах. Этот отчет всегда отдает все товары, но сравнительно «легковесен», так как содержит только информацию об остатках (и метаданные товара). Например, для товара будет указано: остаток на складе А = 5, на складе Б = 0 и т.д. Один из подходов – хранить на сайте кеш предыдущих остатков (например, в транзиентах или отдельной табличке: product_id → количество). Каждые 10 минут запрашивать /report/stock/bystore и сравнивать с сохраненными значениями. Обновлять только те товары, у которых количество изменилось. Таким образом, даже если отчет возвращает 2000 товаров, мы быстро проходим по массиву и выявляем изменения (скажем, 5 товаров с другими остатками). Затем обращаемся к WooCommerce для обновления только этих позиций. Этот подход все же требует загрузки JSON со всеми товарами, но только раз в 10 минут. Для ~2000 товаров объем данных приемлем: отчет – это ~2000 записей с парой чисел и meta-ссылкой. При gzip-сжатии по HTTP трафик вполне небольшой. Более того, можно сузить отчет по складам: если у вас интересует только один склад, stock/bystore можно вызвать с параметром фильтрации по конкретному складу (или выбрать нужный из массива). В API также есть report/stock/all и другие разновидности отчета остатков – можно выбрать подходящий. Главное, что вы не делаете множество запросов (достаточно 1 запрос на отчет раз в 10 минут). Недостаток – всё равно происходит перебор всех товаров на стороне сервера (в цикле сравнения), но 2000 элементов – небольшое число для PHP, это пройдет быстро даже на слабом хостинге. в) Запрос только изменившихся через журнал или фильтры операций: Альтернативный вариант – опрашивать документы, влияющие на остатки (поступления, продажи, списания) за последние 10 минут. Например, запросить список продаж (отгрузок) за интервал, поступлений за интервал и т.д., собрать уникальные товары, которые в них фигурировали, и обновить только их. Однако, это усложняет... [truncated]
3. Планирование фоновых задач: WP-Cron vs системный cron
Для регулярного запуска синхронизации каждые 10 минут нужно настроить задачу либо через WP-Cron, либо через системный cron сервера. WP-Cron (внутренний планировщик WordPress):
Позволяет планировать выполнение функций при посещениях сайта. Можно зарегистрировать собственный интервал (600 секунд) и событие. Например, при активации плагина вызвать:
if( !wp_next_scheduled('moysklad_stock_sync') ) {
    wp_schedule_event(time(), 'every_ten_minutes', 'moysklad_stock_sync');
}
где 'every_ten_minutes' – настраиваемый интервал (через фильтр cron_schedules можно добавить 10-минутный интервал). Затем повесить функцию на хук 'moysklad_stock_sync', которая и будет выполнять логику: соединяться с API МоегоСклада, получать изменения и обновлять WooCommerce. Плюс WP-Cron: не требует доступа к серверу, все делается в PHP. Минусы: WP-Cron срабатывает только при активности сайта. Если трафик низкий, 10-минутный интервал может не соблюдаться (задача выполнится с задержкой до следующего хита). Кроме того, на слабом хостинге важно, чтобы предыдущая задача успела завершиться до запуска следующей, иначе задачи начнут накапливаться. Для 2000 товаров / 10 мин это, скорее всего, успеет. Системный cron:
Надежнее в плане расписания. Вы можете настроить на сервере (если есть доступ к cron) вызов каждые 10 минут, например, URL https://вашсайт/cron-handler.php или команды WP-CLI. В WordPress можно использовать WP-CLI команду wp cron event run --due-now на крон, либо сделать отдельный PHP-скрипт с включением WP-движка (wp-load.php) и вызовом нужной функции. Системный cron не зависит от посетителей, так что задача выполнится точно по расписанию. Многие shared-хостинги позволяют cron-задания через панель управления. Рекомендация: если есть возможность, лучше настроить реальный cron (он же может запускать WP-Cron принудительно). Если нет – WP-Cron тоже справится, просто следите за нагрузкой и своевременностью. Важно: не запускать скрипт синхронизации параллельно. Т.е. если по каким-то причинам предыдущий sync еще идет, а пришло время следующего, лучше пропустить или дождаться первого. Это можно контролировать с помощью блокировок (например, transient или флаг опции «синхронизация в процессе»). Иначе, на слабом сервере, две синхронизации одновременно точно перегрузят систему.
Обновление остатков в WooCommerce (REST API vs прямое обновление)
Когда мы получили актуальные данные из МойСклад, их нужно применить на сайте WooCommerce. Здесь есть два основных подхода: 1. Использовать REST API WooCommerce:
WooCommerce предоставляет REST API endpoints для товаров. При наличии Consumer Key/Secret (или используя приложение/токен) можно делать PUT/PATCH запросы к /wp-json/wc/v3/products/{id} с передачей новых данных. Например, отправить JSON {"stock_quantity": 5, "stock_status": "instock"} для обновления остатка товара. Можно делать и batched-запросы (WooCommerce REST поддерживает пакетное обновление до 100 товаров за раз через POST /products/batch). Использование REST API удобно, если синхронизация реализована вне WordPress (например, отдельный скрипт или облачный сервис): тогда REST API – стандартный способ изменить данные, и WooCommerce сам обработает изменения (например, поменяет статус «В наличии» или «Нет на складе» в зависимости от количества). Однако, REST API – это дополнительная нагрузка HTTP на ваш же сервер (если скрипт запущен на том же хостинге). Фактически скрипт отправляет запрос серверу, чтобы тот через WordPress обновил базу. На 2000 товаров каждые 10 мин это может быть ощутимо, если обновлений много. В нашем случае обновлений будет мало (инкрементально), но все равно: при 5 изменившихся товарах – 5 отдельных HTTP вызовов (или 1 batched). 2. Обновлять напрямую внутри WordPress (мета-данные или WooCommerce функции):
Если синхронизационный код выполняется внутри плагина на сайте, то эффективнее миновать внешний REST слой. Вы можете использовать функции WooCommerce или обновлять мета-поля товара напрямую через WP API. Стандартный способ: загрузить объект продукта и установить новое количество:
$product = wc_get_product($product_id);
$product->set_stock_quantity(5);
$product->set_stock_status('instock');
$product->save();
Это вызовет все внутренние хуки WooCommerce (например, пересчет сумм для вариативных товаров, если нужно, и т.д.). Можно и непосредственными функциями: update_post_meta($product_id, '_stock', 5) и update_post_meta($product_id, '_stock_status', 'instock'). Не забудьте, что если у товара включено управление запасами (_manage_stock = yes), WooCommerce сам рассчитывает _stock_status на основе _stock. Обычно при $product->save() всё это учитывается. Плюс прямого подхода: не тратится время на HTTP-запросы – вы уже в контексте WordPress, сразу пишете в базу. Минус: код чуть сложнее, нужен сам WordPress (но в нашем случае мы пишем плагин, так что это естественно). Выбор подхода: В кастомном плагине предпочтительно обновлять через WooCommerce API функций. REST пригодится, если, например, вы решили реализовать синхронизацию вне WP. В контексте WP-Cron задачи – используем функции WooCommerce. Примечание: WooCommerce не хранит историю изменений остатков, поэтому “умной” внутренней функции «обновить только если изменилось» нет – но вы можете сами сравнить: перед обновлением проверить текущее _stock в базе и новое значение, и если они совпадают, пропустить. Это избегнет лишних операций и записи в базу. Однако если вы уже отфильтровали на этапе получения данных, то на обновление попадут только реально изменившиеся товары.
Примеры реализации синхронизации
Ниже приведен упрощенный пример, демонстрирующий ключевые части кода для синхронизации. Он предполагает, что мы храним время последней синхронизации в опции moysklad_last_sync и используем JSON API МоегоСклада для выборки изменений: 1. Планирование задачи каждые 10 минут (WP-Cron):
// Добавляем пользовательский интервал 10 минут
add_filter('cron_schedules', function($schedules){
    $schedules['every_ten_minutes'] = [
        'interval' => 600,
        'display'  => 'Каждые 10 минут'
    ];
    return $schedules;
});

// Планируем событие при активации плагина
register_activation_hook(__FILE__, function(){
    if(!wp_next_scheduled('moysklad_stock_sync')){
        wp_schedule_event(time()+60, 'every_ten_minutes', 'moysklad_stock_sync');
    }
});

// Отмена планирования при деактивации (чистка)
register_deactivation_hook(__FILE__, function(){
    $timestamp = wp_next_scheduled('moysklad_stock_sync');
    if($timestamp){
        wp_unschedule_event($timestamp, 'moysklad_stock_sync');
    }
});
2. Обработчик события синхронизации:
add_action('moysklad_stock_sync', 'my_sync_moysklad_stocks');
function my_sync_moysklad_stocks(){
    // Блокировка, чтобы не было параллельных запусков
    if( get_transient('ms_sync_lock') ){
        return; // предыдущий sync еще идет
    }
    set_transient('ms_sync_lock', 1, 600);
    $lastSync = get_option('moysklad_last_sync');
    $now = current_time('mysql'); // время текущей синхронизации
    
    $changedProducts = [];
    if($lastSync){
        // Попытка получить товары с обновлением после $lastSync
        $url = "https://online.moysklad.ru/api/remap/1.2/entity/product?filter=updated>{$lastSync}";
    } else {
        // Первая загрузка: возьмем все товары (ограничим 2000 через параметр?)
        $url = "https://online.moysklad.ru/api/remap/1.2/entity/product";
    }
    $response = wp_remote_get($url, [
        'headers' => ['Authorization' => 'Basic ' . base64_encode(MS_LOGIN.':'.MS_PASSWORD)]
    ]);
    if(is_wp_error($response)){
        // Логирование ошибки...
        delete_transient('ms_sync_lock');
        return;
    }
    $data = json_decode(wp_remote_retrieve_body($response), true);
    if(isset($data['rows'])){
        foreach($data['rows'] as $item){
            // Проверяем поле остатков, например:
            if(isset($item['stock'])){
                $changedProducts[$item['id']] = $item['stock'];
            } elseif(isset($item['quantity'])){ 
                // Возможно, в ассортименте поле quantity = текущий остаток
                $changedProducts[$item['id']] = $item['quantity'];
            }
        }
    }
    // $changedProducts теперь содержит ID товаров (UUID МоегоСклада) и новые остатки.
    // Нужно сопоставить их с товарами WooCommerce (например, по артикулу или сохраненному соответствию ID).
    // Предположим, у нас у каждого продукта WooCommerce в meta хранится moysklad_uuid.
    foreach($changedProducts as $ms_uuid => $new_qty){
        $wc_product_id = find_product_by_moysklad_uuid($ms_uuid);
        if(!$wc_product_id) continue;
        // Получаем текущий остаток на сайте
        $current_stock = get_post_meta($wc_product_id, '_stock', true);
        if($current_stock === '') $current_stock = null; // not set
        // Сравниваем с новым
        if($current_stock === null || floatval($current_stock) !== floatval($new_qty)){
            // Обновляем товар
            wc_update_product_stock($wc_product_id, $new_qty);
            // wc_update_product_stock сама обновит статус (в наличии/нет) в зависимости от qty и настроек backorder.
            // Альтернативно: wc_get_product + set_stock_quantity как выше.
        }
    }
    update_option('moysklad_last_sync', $now);
    delete_transient('ms_sync_lock');
}
В реальном коде потребуется учесть много деталей: аутентификацию, постраничную загрузку (если товаров >1000 за раз, API выдает постранично), сопоставление товаров (например, по артикулу (SKU) или сохраненному UUID МоегоСклада в метаданных товара WooCommerce). Также, если ведется учет по нескольким складам, надо решить, с какого склада брать остатки для сайта (либо суммарно, либо один определённый склад – API отчет/запрос позволяет фильтровать по складу). В MSWoo, например, есть настройка «выбрать склад, с которого грузятся остатки»
mswoo.ru
. Пример получения остатков через отчет stock/bystore: вместо запроса entity/product выше можно сделать:
$url = "https://online.moysklad.ru/api/remap/1.2/report/stock/bystore?store.id={$STORE_ID}";
$response = wp_remote_get($url, [ /* auth */ ]);
$data = json_decode(wp_remote_retrieve_body($response), true);
if(isset($data['rows'])){
    foreach($data['rows'] as $row){
        $ms_uuid = $row['meta']['href']; // в href будет URL товара с его UUID
        // можно извлечь UUID товара из href
        $uuid = preg_replace('#.*/([^/]+)$#', '$1', $ms_uuid);
        // Теперь пробежать по stockByStore и найти нужный склад:
        foreach($row['stockByStore'] as $stockEntry){
            if($stockEntry['meta']['href'] === $desired_store_href){
                $new_qty = $stockEntry['stock']; // например, поле "stock"
                $changedProducts[$uuid] = $new_qty;
            }
        }
    }
}
Этот псевдокод собирает остатки нужного склада для каждого товара. Далее так же сравнивает и обновляет.
4. Оптимизация производительности
Чтобы решение было ненагружающим, следует учесть:
Частичное обновление каталога: как описано, опрашивать или обрабатывать только изменения. Полная синхронизация каждые 10 мин не нужна. Если даже приходится получать полный список остатков, отфильтруйте изменения прежде чем писать в базу.
Разделение на этапы (batch processing): Если каталог очень большой (тысячи товаров) и даже перебор отчета может занимать больше 10 минут, можно разбить обновление на несколько шагов. Например, планировать кроном запуск разных частей (с 0–999 ID в одном запуске, 1000–1999 в другом, или по группам товаров). Но для 2000 товаров это вряд ли потребуется – это не столь большой объем.
Ограничение частоты: 10 минут – довольно часто. Убедитесь, что бизнес-действительно требует такую частоту. Может быть, достаточно 15 или 30 минут, что снизит нагрузку вдвое. Но если остатки быстро меняются (например, многоканальные продажи), 10 минут обоснованно.
Контроль ошибок и таймаутов: Если вдруг API МоегоСклада не ответил ( сеть лагает ) – не запускайте массово повторно сразу. Логируйте ошибку, следующее срабатывание через 10 мин попробует снова. Также соблюдайте лимиты API: у МоегоСклада есть ограничения на количество запросов в минуту (если много товаров, лучше использовать один запрос-отчет, чем 2000 отдельных запросов по товару).
Не хранить лишние данные: Только минимальное – например, время последней синхронизации и, опционально, кеш остатков для сравнения. Все остальное приходит по API.
Готовые решения и их особенности
Существуют готовые плагины и интеграционные сервисы для связки МойСклад + WooCommerce. Рассмотрим их кратко, с фокусом на метод синхронизации остатков:
WooMS (плагин от WPCraft) – бесплатный плагин с репозитория WordPress
wordpress.com
. Он использует REST API МоегоСклада для синхронизации каталога, категорий, изображений и т.п. Судя по открытым исходникам, WooMS загружает товары партиями и обновляет их на сайте. В базовой версии обновление остатков происходит через периодический опрос (WP-Cron). Вероятно, плагин хранит некий «журнал» или метку, какие товары уже синхронизированы, и при каждом запуске подгружает следующую порцию или недавно изменившиеся. Однако, пользователи отмечали нюансы: например, опция учитывать резерв может отсутствовать в бесплатной версии. В целом WooMS – решение «из коробки», но может не быть оптимальным по производительности для больших каталогов (оно универсальное, не заточено только под остатки). О том, инкрементально ли оно обновляет остатки, прямых цитат нет, но логично предположить, что после первоначальной синхронизации оно обновляет только изменившееся (возможно, с помощью поля updated, хотя, как мы знаем, оно не ловит чисто складские изменения).
MSWoo (платный плагин) – продвинутый коммерческий плагин интеграции
mswoo.ru
. По описанию, ориентирован на большие объемы. Имеет настройки частоты обновления остатков (раз в день, раз в час и т.п.)
mswoo.ru
 – то есть может не позволять каждые 10 минут через интерфейс, но, скорее всего, можно выставить крон чаще вручную. Главное – MSWoo поддерживает частичную синхронизацию: можно включить опцию «обновлять только те товары, что обновились в МС»
mswoo.ru
. Кроме того, у них есть два режима синхронизации: стандартный – загружает товары частями (более щадяще для слабого сервера, но дольше по времени), и ускоренный – загружает все сразу, быстрее, но требовательнее к ресурсам
mswoo.ru
. Наличие стандартного режима подтверждает наш подход: для слабого хостинга лучше порционно или постепенно обновлять, избегая длинных единовременных операций. MSWoo также умеет работать через вебхуки
mswoo.ru
 – в этом случае остатки обновляются моментально при изменениях в МойСклад, без периодического опроса. Вероятно, плагин при активных вебхуках регистрирует их в МойСклад и обрабатывает входящие уведомления.
Сервисы интеграции (Albato, Zapier-аналоги) – Albato предлагает готовые сценарии: вы настраиваете триггер «Обновление остатков после ... (продажи/поступления и т.д.)» и действие «Обновить товар в WooCommerce». Это полностью событийный подход. Он гарантирует обновление только того товара, которого коснулось событие. Например, при продаже товара X через розничную точку, Albato получит webhook «остатки изменены после отгрузки» с данными по товару X и вызовет обновление именно товара X на сайте
albato.ru
. Такие сервисы разгружают вас от написания кода, но стоят денег и добавляют внешнего посредника. По сути, Albato или аналог работает так же, как мы описали в разделе про вебхуки, только без вашего кода – вы на их сайте «соединяете» события МойСклад и действия WooCommerce. Обновление остатков через них выборочное (селективное), никаких полных синков.
Другие плагины и модули: на рынке есть решения от интеграторов (AM-Group, ProResult, Helpist и др.). Некоторые могут основываться на CommerceML (например, связка через обмен XML раз в час). Другие – на REST API. Стоит уточнить у каждого, используют ли они дельта-обновление. Если написано «всё обновляется автоматически», это не раскрывает метод. Но, например, ProResult (для amoCRM) упоминает «с помощью последних возможностей JSON API 1.2... остатки в режиме реального времени»
acrit-studio.ru
 – вероятно, тоже вебхуки. Решения типа Robokassa Module для WooCommerce имели интеграцию с МойСклад (через CommerceML)
docs.robokassa.ru
, что в контексте остатков означает обмен файлами. Это не подходит для 10-минутного интервала на слабом хостинге (слишком тяжелый процесс).
Вывод по готовым решениям: Если бюджет позволяет, плагин MSWoo предлагает наибольшую гибкость (вебхуки, выбор режимов). Бесплатный WooMS тоже может решать задачу, но нужно протестировать его поведение с остатками (в сообществе были вопросы по корректности обновления резервов и остатков). Альтернативно, облачные интеграторы обеспечивают выборочную синхронизацию без нагрузки на ваш хостинг (вся логика у них), но требуют доверить им доступ к данным и абонентскую плату.
Рекомендации для кастомного плагина синхронизации
Оптимальная реализация собственного плагина для синхронизации остатков между МойСклад и WooCommerce должна учитывать следующие принципы:
Инкрементальность: Храните отметку времени последней синхронизации и/или слепок остатков, чтобы при следующем запуске обработать только изменения. Избегайте полных обменов. Это краеугольный камень производительности. Как мы рассмотрели, ни API, ни база данных сайта не будут лишний раз тронуты по 1900 товарам из 2000, если у них ничего не менялось.
Использование возможностей API 1.2: Задействуйте вебхуки, если можете – тогда ваш плагин вообще не будет по расписанию дергать данные, вместо этого он будет ждать уведомлений и сразу их применять. Если вебхуки не используются, применяйте запросы-отчеты или фильтры API, чтобы снизить объем передаваемых данных. Например, один запрос отчетности лучше, чем тысячи мелких. JSON API достаточно шустрый и гибкий для этих целей
ru.stackoverflow.com
.
Учёт резервов и нескольких складов: Решите, какой именно остаток вы синхронизируете. В МойСклад есть понятия общего остатка, резерва и доступного количества. Если интернет-магазин продает товары с одного склада, логично брать остаток только этого склада. Если продаете совокупный остаток со всех складов – API отчет может дать суммарный остаток (поле stock или quantity обычно суммарное по всем складам). Резервы (резервированные товары под заказ) могут учитываться: например, можно синхронизировать доступный остаток = общий минус резерв. Убедитесь, что ваш метод получает эти данные. (Ассортимент API возвращает поля quantity – остаток на всех складах, reserve – зарезервировано, inTransit и quantityFreeToSell – свободно для продажи, если включены соответствующие опции
ru.stackoverflow.com
ru.stackoverflow.com
.) Если нужно учитывать резерв – берите quantityFreeToSell вместо полного quantity.
Расписание 10 минут: Настройте WP-Cron и/или внешний cron как описано, и протестируйте, что задачи не пропускаются. Возможно, на шаред-хостинге WP-Cron по умолчанию не очень точный – тогда лучше настроить «pseudo-cron»: вызвать wp-cron.php с внешнего cron job каждые 10 минут. Многие хостинги даже рекомендуют отключить WP-Cron и использовать системный cron для надежности.
Обработка ошибок и уведомления: Добавьте логирование – хотя бы в error_log записывать время синхронизации, сколько товаров обновлено, и ошибки API. Так вы сможете отследить, если что-то пошло не так (например, авторизация к API потеряла силу, или поменялись ID). Также имеет смысл реализовать повторный запрос при получении неудачного ответа (с экспоненциальной задержкой, но это уже тонкости).
Тестирование нагрузки: Протестируйте плагин на копии сайта. Сымитируйте сценарий, когда изменяется много товаров, и убедитесь, что выполнение укладывается в разумное время (несколько секунд). 2000 товаров – не столь большой объем; даже полный импорт такого количества через REST API может уложиться в 1-2 минуты. Но на слабом сервере лучше, чтобы каждое 10-минутное окно тратило, скажем, не более 10-20 секунд CPU. Инкрементальный подход этого легко достигает (если изменилось 5 товаров – обновление займет меньше секунды).
Совместимость с кешами и фронтом: Если у вас на сайте включен объектный кеш или кеш страниц, убедитесь, что при обновлении остатков меняется статус наличия, чтобы, например, товар, ушедший в ноль, стал отмечен «Нет в наличии» (WooCommerce это делает через _stock_status). Возможно, потребуется сбрасывать кеш страниц товара или каталога, если он не обновляется сам. Но это уже отдельный аспект (чаще всего плагины кеширования при изменении продукта сбрасывают кеш автоматически).
Наконец, подход «кастомного плагина» хорош тем, что вы контролируете процесс. Вы можете начать с простого: cron + запрос отчета + обновление мета. Затем, по мере роста или необходимости, добавить улучшения: например, переключиться на вебхуки для мгновенности, или добавить дополнительные проверки (обновление цен параллельно, синхронизацию новых товаров и т.д.). Главное – заложить правильную архитектуру с самого начала: раздельная обработка изменений и минимизация нагрузки. Следуя этим принципам, синхронизация каждые 10 минут будет выполняться плавно и без перегрузок, обеспечивая актуальные остатки на сайте практически в реальном времени.